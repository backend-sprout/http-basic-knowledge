# 인터넷 통신  
직접 연결된 컴퓨터간의 통신은 직접적인 회선을 통해 진행하면 된다.         
하지만, 긴 거리에 있는 컴퓨터와 통신을 하고자 한다면 인터넷을 이용해야한다.           
인터넷은 다양한 노드들과 이들이 연결된 네트워크를 의미한다.        
그렇다면 우리는 우리가 원하는 특정 컴퓨터에게 어떻게 데이터를 전송할 수 있을까?    
   
# IP(인터넷 프로토콜) 
IP는 컴퓨터 네트워크에서 장치들이 서로를 인식하고 통신을 하기 위해서 사용하는 특수한 번호이다.    
      
IP를 이용한 데이토 통신은 아래와 같은 형식을 가진다.        
* 지정한 IP주소(IP Address)에 데이터를 전달     
* 패킷이라는 통신 단위로 데이터 전달 (이를 IP 패킷이라 부른다.)        
* 패킷에는 `출발지IP`, `목적지 IP`, **`전송데이터`**, 기타 등등.. 이 포함된다.          
           
**서버 패킷 전달**           
데이터 통신을 진행하면 우리는 패킷 단위로 데이터를 전달한다.          
패킷은 `출발지IP`, `목적지 IP`, **`전송데이터`**, 기타 등등을 가지고 목적지로 이동을 한다.        
패킷이 모두 목적지로 이동되면 목적지에서 다시 요청지로 OK 응답을 보낸다.      
    
참고로, 고정된 경로를 쓰는지 아니면 동적인 경로를 쓰는지 전략마다 다르지만         
데이터를 보내는는 과정에서 내가 지나온 경로와 응답을 받는 경로가 다를 수 있다.     
  
**IP 프로토콜 한계**      
* 비연결성
  * 패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷 전송이 가능하다.   
* 비신뢰성
  * 중간에 패킷이 사라질 수 있다.   
  * 패킷이 순서대로 오지 않을 수 있다.    
* 프로그램 구분 
  * 같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 2 이상일 경우 사용하기 힘들다.    
  * 즉, 같은 IP를 사용하는 여러 애플리케이션을 동시에 실행하지 못하게 하기 때문이다.  
             
위와 같은 이유 때문에 IP를 이용한 통신은 지양한다.         
그렇기에 이러한 문제를 해결하기 위해 TCP/UDP 프로토콜을 함께 이용한다.   
        
# TCP/UDP    
**인터넷 프로토콜 스택의 4계층**   
* 애플리케이션 계층 : HTTP, FTP  
* 전송 계층 : TCP, UDP
* 인터넷 계층 : IP
* 네트워크 인터페이스 계층
        
**프로토콜 계층**    
* **애플리케이션 :**   
  웹브라우저, 네트워크 게임, 채팅 프로그램 등등  
  Socket 라이브러리
* **OS :**    
  TCP/UDP,IP  
* **네트워크 인터페이스 :**  
  LAN 드라이버, LAN 장비, LAN카드(이를 통해 인터넷 서버에 접속한다)        
     
우리가 데이터를 전송하는 과정은 위와 같은 계층이         
위에서부터 아래로 하나씩 내려오면서 진행이되는 것이다.       
   
1. 프로그램에서 hello,world 작성했다 가정한다.      
2. 애플리케이션은 Socket 라이브러리를 통해 OS로 전송한다.    
3. OS에서 TCP는 정보 생성하고, 메시지 데이터를 포함시킨다.     
4. OS에서 IP는 IP 패킷을 생성하고, TCP 데이터를 포함시킨다.     
5. 이후 Ethernet Frame을 붙이고 LAN 카드를 통해 통신을 시작한다. 
    * Ethernet Frame은 실제 MAC 주소와 같은 물리적인 데이터를 가지고 있다.   

**IP 패킷 정보**    
* IP 패킷 : `출발지 IP`, `목적지 IP`, `기타...`   
* 데이터 : `전송 데이터`
         
패킷은 `패키지` + `버킷`의 합성어로     
수화물을 보면 캐리어 안에 물건을 넣듯이     
데이터를 이와 관련된 요소들에 넣어놓은 것이라고 생각하면 된다.    
         
**TCP/IP 패킷 정보(TCP 세그먼트)**
* IP 패킷 : `출발지 IP`, `목적지 IP`, `기타...`   
* TCP 세그먼트 : `출발지 PORT`, `목적지 PORT`, `전송 제어`, `순서`, `검증 정보`, `기타...`   
* 데이터 : `전송 데이터`
         
`IP 패킷` **안에** `TCP 세그먼트`를 감싼 형태라고 생각하면 된다.      
실은 계층을 내려오면서 데이터 위에 `TCP 세그먼트`가 감싸지고 그 다음 `IP 패킷`이 감싸진 형태이다.  
         
**TCP 특징**      
* 연결지향 - `TCP 3 way handshake(가상 연결)`          
* 데이터 전달 보증       
* 순서 보장         
* 신뢰할 수 있는 프로토콜    
* 현재는 대부분 TCP 사용   


**TCP 3 way handshake**       
    
1. 클라이언트에서 Connection 을 위한 SYN을 서버에 보낸다.       
2. 서버는 `SYN`을 받으면 마찬가지로 Connection 을 위한 `SYN`과 응답을 위한 `ACK`을 함께 보낸다.    
3. 클라이언트는 `ACK`을 통해 커넥션 준비가 완료되었다 판단하고           
   마찬가지로 서버의 `SYN`요청에 대한 `ACK`을 다시 보낸다. (서버는 받으면 완료되었다고 판단)              
4. `TCP 3 way handshake` 이후라고 생각 -> 이제부터 서로간에 데이터를 전송할 수 있게 되었다.     

* SYN : 접속 요청       
* ACK : 요청 수락         
    
참고로 알아 둘 것은, 위 같은 과정은 개념적(논리적)으로 연결이 된 것이다.        
즉, 실제 물리적으로 연결된 것은 아니지만 앞서 언급했던 `가상 연결`이 확립된 것이고    
이로 인해 `연결 지향`의 장점을 가질 수 있게 되었던 것이다.    
이 외에도 Connection 종료를 위한 `TCP 4 way handshake` 도 있다.           
  
**데이터 전달 보증**  

1. 데이터 전송
2. 데이터 잘 받았음 
   
데이터를 수신했디면 송신한 컴퓨터쪽으로 데이터를 잘 받았다는 메시지를 보내준다.      


**참고**   
여기서 sync/async, block/nonblock 개념이 나오니 이부분은 따로 공부하자    
우선 간단히 말하면, `sync`/`async` 는 데이터를 전송하고 응답을 기다리는지에 관한 것이고  
`block/nonblock`은 흐름의 주체권이 어디로 갔냐이다.   
   
**순서 보장**   

1. 패킷1, 패킷2, 패킷3 순서로 전송
2. 패킷1, 패킷3, 패킷2 순서로 도착
3. 서버는 클라이언트에세 `패킷2 ..` 부터 다시 보내라고 요청
   
패킷의 순서가 잘못되었거나 패킷에 에러가 발생했을 경우   
서버는 클라이언트에게 패킷 재요청을 보낸다.   

그리고 이러한 모든 것들을 가능하게 한것은 TCP 세그먼트에 포함된 정보들 덕분이다.   

## UDP    
> 사용자 데이터그램 프로토콜(User Datagram Protocol)   

* 하얀 도화지에 비유 (기능이 거의 없다)   
* 연결지향 - TCP 3 way handshake - X 
* 데이터 전달 보증 - X 
* 순서 보장 - X
* 데이터 전달 및 순서가 보장되지 않지만, 단순하고 빠르다.  
* 장점 : 
    * TCP는 커넥션을 해야하고, 보내는 데이터도 많기에 속도면에서 최적화를 하기 힘들다.  
    * 반면, UDP는 도화지이기에 우리가 원하는 최적화를 진행할 수 있다.   
    * 최근에는 곽광을 받고 있다. (API가 많아지니까)
    * HTTP3 에서도 UDP 프로토콜로 전환하고 있다.   
* 정리 
    * IP와 거의 같다 + PORT + 체크섬 정도만 추가 
    * 애플리케이션에서 추가 작업이 필요하다  
    * 대신, 내가 무언가 최적화를 하고 싶을 때는 UDP를 이용할 수 있다.     
    
# PORT
# DNS
